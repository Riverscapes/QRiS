# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QRiSDockWidget
                                 A QGIS plugin
 QGIS Riverscapes Studio (QRiS)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-05-06
        git sha              : $Format:%H$
        copyright            : (C) 2021 by North Arrow Research
        email                : info@northarrowresearch.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from functools import partial
from osgeo import ogr

from qgis.core import QgsApplication, Qgis, QgsWkbTypes, QgsProject, QgsVectorLayer, QgsFeature, QgsVectorFileWriter, QgsCoordinateTransformContext, QgsField, QgsRectangle, QgsRasterLayer, QgsMessageLog, QgsLayerTreeNode
from qgis.utils import iface
from PyQt5 import QtCore, QtGui, QtWidgets
from qgis.gui import QgsMapToolEmitPoint
from PyQt5.QtCore import pyqtSlot, QVariant, QDate, QModelIndex

from ..model.scratch_vector import ScratchVector, scratch_gpkg_path
from ..model.layer import Layer
from ..model.project import Project, PROJECT_MACHINE_CODE
from ..model.event import EVENT_MACHINE_CODE, DESIGN_EVENT_TYPE_ID, AS_BUILT_EVENT_TYPE_ID, Event
from ..model.raster import BASEMAP_MACHINE_CODE, PROTOCOL_BASEMAP_MACHINE_CODE, SURFACE_MACHINE_CODE, Raster
from ..model.analysis import ANALYSIS_MACHINE_CODE, Analysis
from ..model.db_item import DB_MODE_NEW, DB_MODE_CREATE, DB_MODE_IMPORT, DB_MODE_IMPORT_TEMPORARY, DB_MODE_PROMOTE, DB_MODE_COPY, DBItem
from ..model.mask import AOI_MACHINE_CODE, AOI_MASK_TYPE_ID, Mask
from ..model.sample_frame import SAMPLE_FRAME_MACHINE_CODE, SampleFrame
from ..model.protocol import Protocol
from ..model.method import Method
from ..model.pour_point import PourPoint, CATCHMENTS_MACHINE_CODE
from ..model.stream_gage import StreamGage, STREAM_GAGE_MACHINE_CODE, STREAM_GAGE_NODE_TAG
from ..model.event_layer import EventLayer
from ..model.profile import Profile
from ..model.cross_sections import CrossSections

from .frm_design2 import FrmDesign
from .frm_event import DATA_CAPTURE_EVENT_TYPE_ID, FrmEvent
from .frm_asbuilt import FrmAsBuilt
from .frm_basemap import FrmRaster
from .frm_mask_aoi import FrmMaskAOI
from .frm_sample_frame import FrmSampleFrame
from .frm_analysis_properties import FrmAnalysisProperties
from .frm_new_project import FrmNewProject
from .frm_pour_point import FrmPourPoint
from .frm_analysis_docwidget import FrmAnalysisDocWidget
from .frm_slider import FrmSlider
from .frm_scratch_vector import FrmScratchVector
from .frm_geospatial_metrics import FrmGeospatialMetrics
from .frm_stream_gage_docwidget import FrmStreamGageDocWidget
from .frm_centerline_docwidget import FrmCenterlineDocWidget
from .frm_cross_sections_docwidget import FrmCrossSectionsDocWidget
from .frm_profile import FrmProfile
from .frm_cross_sections import FrmCrossSections
# from .frm_sampleframe import FrmSampleFrame
from .frm_import_dce_layer import FrmImportDceLayer
from .frm_toc_layer_picker import FrmTOCLayerPicker
from .frm_export_metrics import FrmExportMetrics
from .frm_event_picker import FrmEventPicker
from .frm_export_design import FrmExportDesign
from .frm_export_project import FrmExportProject
from .frm_import_photos import FrmImportPhotos

from ..QRiS.settings import Settings, CONSTANTS
from ..QRiS.qris_map_manager import QRisMapManager
from ..QRiS.riverscapes_map_manager import RiverscapesMapManager

from ..gp.feature_class_functions import browse_raster, browse_vector, flip_line_geometry, import_existing
from ..gp.import_temp_layer import ImportTemporaryLayer
from ..gp.stream_stats import transform_geometry, get_state_from_coordinates
from ..gp.stream_stats import StreamStats
from ..gp.metrics_task import MetricsTask

ORGANIZATION = 'Riverscapes'
APPNAME = 'QRiS'
LAST_PROJECT_FOLDER = 'last_project_folder'
CONTEXT_NODE_TAG = 'CONTEXT'
INPUTS_NODE_TAG = 'INPUTS'

# Name of the icon PNG file used for group folders in the QRiS project tree
# /Images/folder.png
FOLDER_ICON = 'folder'

# These are the labels used for displaying the group nodes in the QRiS project tree
GROUP_FOLDER_LABELS = {
    INPUTS_NODE_TAG: 'Inputs',
    SURFACE_MACHINE_CODE: 'Surfaces',
    AOI_MACHINE_CODE: 'AOIs',
    SAMPLE_FRAME_MACHINE_CODE: 'Sample Frames',
    EVENT_MACHINE_CODE: 'Data Capture Events',
    BASEMAP_MACHINE_CODE: 'Basemaps',
    PROTOCOL_BASEMAP_MACHINE_CODE: 'Basemaps',
    ANALYSIS_MACHINE_CODE: 'Analyses',
    CATCHMENTS_MACHINE_CODE: 'Watershed Catchments',
    CONTEXT_NODE_TAG: 'Context',
    STREAM_GAGE_MACHINE_CODE: 'Stream Gages',
    Profile.PROFILE_MACHINE_CODE: 'Profiles',
    CrossSections.CROSS_SECTIONS_MACHINE_CODE: 'Cross Sections'
}


class QRiSDockWidget(QtWidgets.QDockWidget):

    closingPlugin = QtCore.pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(QRiSDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # widgets-and-dialogs-with-auto-connect
        self.setupUi()
        self.iface = iface

        self.settings = Settings()

        self.qris_project = None
        self.map_manager = None
        self.basemap_manager = None
        self.menu = QtWidgets.QMenu()

        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeView.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.treeView.customContextMenuRequested.connect(self.open_menu)
        # self.treeView.doubleClicked.connect(self.default_tree_action)
        # self.treeView.clicked.connect(self.item_change)
        # self.treeView.expanded.connect(self.expand_tree_item)

        self.analysis_doc_widget = None
        self.slider_doc_widget = None
        self.stream_gage_doc_widget = None
        self.centerline_doc_widget = None
        self.cross_sections_doc_widget = None

        self.stream_stats_tool = QgsMapToolEmitPoint(self.iface.mapCanvas())
        self.stream_stats_tool.canvasClicked.connect(self.stream_stats_action)

        self.qrave = None

    def build_tree_view(self, project_file, new_item=None):
        """
        Builds the project tree from scratch for the first time
        """
        self.project = Project(project_file)
        self.map_manager = QRisMapManager(self.project)
        self.map_manager.edit_mode_changed.connect(self.on_edit_session_change)

        self.model = QtGui.QStandardItemModel()
        self.treeView.setModel(self.model)
        self.tree_state = {}
        rootNode = self.model.invisibleRootItem()

        # set the project root
        project_node = self.add_child_to_project_tree(rootNode, self.project)
        inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG)

        surfaces_node = self.add_child_to_project_tree(inputs_node, SURFACE_MACHINE_CODE)
        [self.add_child_to_project_tree(surfaces_node, item) for item in self.project.rasters.values() if item.is_context is False]

        aoi_node = self.add_child_to_project_tree(inputs_node, AOI_MACHINE_CODE)
        [self.add_child_to_project_tree(aoi_node, item) for item in self.project.aois.values() if item.mask_type.id == AOI_MASK_TYPE_ID]

        sample_frames_node = self.add_child_to_project_tree(inputs_node, SAMPLE_FRAME_MACHINE_CODE)
        [self.add_child_to_project_tree(sample_frames_node, item) for item in self.project.sample_frames.values()]

        profiles_node = self.add_child_to_project_tree(inputs_node, Profile.PROFILE_MACHINE_CODE)
        [self.add_child_to_project_tree(profiles_node, item) for item in self.project.profiles.values()]

        cross_sections_node = self.add_child_to_project_tree(inputs_node, CrossSections.CROSS_SECTIONS_MACHINE_CODE)
        [self.add_child_to_project_tree(cross_sections_node, item) for item in self.project.cross_sections.values()]

        self.context_node = self.add_child_to_project_tree(inputs_node, CONTEXT_NODE_TAG)
        [self.add_child_to_project_tree(self.context_node, item) for item in self.project.rasters.values() if item.is_context is True]
        [self.add_child_to_project_tree(self.context_node, item) for item in self.project.scratch_vectors.values()]

        # gage_node = self.add_child_to_project_tree(self.context_node, STREAM_GAGE_MACHINE_CODE)
        # [self.add_child_to_project_tree(gage_node, item) for item in self.project.stream_gages.values()]

        catchments_node = self.add_child_to_project_tree(self.context_node, CATCHMENTS_MACHINE_CODE)
        [self.add_child_to_project_tree(catchments_node, item) for item in self.project.pour_points.values()]

        events_node = self.add_child_to_project_tree(project_node, EVENT_MACHINE_CODE)
        [self.add_event_to_project_tree(events_node, item) for item in self.project.events.values()]

        analyses_node = self.add_child_to_project_tree(project_node, ANALYSIS_MACHINE_CODE)
        [self.add_child_to_project_tree(analyses_node, item) for item in self.project.analyses.values()]

        for node in [project_node, inputs_node, surfaces_node, aoi_node, sample_frames_node, profiles_node, cross_sections_node, catchments_node, self.context_node, events_node, analyses_node]:
            self.treeView.expand(self.model.indexFromItem(node))
        if self.qrave is not None:
            if self.qrave.BaseMaps is not None:
                region = self.settings.getValue('basemapRegion')
                self.model.appendRow(self.qrave.BaseMaps.regions[region])
                self.treeView.expand(self.model.indexFromItem(self.qrave.BaseMaps.regions[region]))
                self.basemap_manager = RiverscapesMapManager('Basemaps')
                self.treeView.expanded.connect(self.expand_tree_item)

        # Reconnect any qirs layers back to the edit session signals
        self.traverse_tree(self.model.invisibleRootItem(), self.reconnect_layer_edits)

        return

    def expand_tree_item(self, idx: QModelIndex):
        item = self.model.itemFromIndex(idx)
        item_data = item.data(QtCore.Qt.UserRole)
        if isinstance(item_data, self.qrave.ProjectTreeData):
            if item_data and item_data.data and isinstance(item_data.data, self.qrave.QRaveBaseMap):
                item_data.data.load_layers()

    def setup_blank_map(self, trigger_repaint=False):

        if self.qrave is not None:
            if self.qrave.BaseMaps is not None:
                # add the first basemap to the basemap manager
                region = self.settings.getValue('basemapRegion')
                data = self.qrave.BaseMaps.regions[region].child(0).child(0).data(QtCore.Qt.UserRole)
                self.add_basemap_to_map(data, trigger_repaint=trigger_repaint)
                self.iface.mapCanvas().refresh()
                self.iface.mapCanvas().refreshAllLayers()

    def closeEvent(self, event):

        self.closingPlugin.emit()
        self.destroy_docwidget()
        event.accept()

    def destroy_docwidget(self):

        self.destroy_analysis_doc_widget()

        if self.slider_doc_widget is not None:
            self.slider_doc_widget.close()
            self.slider_doc_widget = None

        if self.stream_gage_doc_widget is not None:
            self.stream_gage_doc_widget.close()
            self.stream_gage_doc_widget = None

        if self.centerline_doc_widget is not None:
            self.centerline_doc_widget.close()
            self.centerline_doc_widget = None

        if self.cross_sections_doc_widget is not None:
            self.cross_sections_doc_widget.close()
            self.cross_sections_doc_widget = None

        # Remove project from map
        # remove_db_item_layer(self.project, self.project)
        # disconnect the map manager
        if self.map_manager is not None:
            if self.map_manager.receivers(self.map_manager.edit_mode_changed) > 0:
                self.map_manager.edit_mode_changed.disconnect()
        self.model = None
        self.qris_project = None

    def destroy_analysis_doc_widget(self):
        if self.analysis_doc_widget is not None:
            # self.analysis_doc_widget.close()
            self.iface.removeDockWidget(self.analysis_doc_widget)
            self.analysis_doc_widget = None

    @pyqtSlot(str, str, dict)
    def qris_from_qrave(self, layer_path, layer_type, metadata):

        if layer_type == 'raster':
            self.add_raster(self.context_node, True, layer_path, meta=metadata)
        else:
            self.add_context_vector(self.context_node, layer_path, meta=metadata)

    def open_menu(self, position):
        """Connects signals as context menus to items in the tree"""
        self.menu.clear()
        indexes = self.treeView.selectedIndexes()
        if len(indexes) < 1:
            return

        # No multiselect so there is only ever one item
        idx = indexes[0]
        if not idx.isValid():
            return

        model_item = self.model.itemFromIndex(indexes[0])
        model_data = model_item.data(QtCore.Qt.UserRole)

        if isinstance(model_data, str):
            if model_data == ANALYSIS_MACHINE_CODE:
                self.add_context_menu_item(self.menu, 'Create New Analysis', 'new', lambda: self.add_analysis(model_item))
                if len(self.project.analyses) > 0:
                    self.add_context_menu_item(self.menu, 'Export All Analyses to Table', 'table', lambda: self.export_analysis_table())
            else:
                self.add_context_menu_item(self.menu, 'Add All Layers To The Map', 'add_to_map', lambda: self.add_tree_group_to_map(model_item))
                if all(model_data != data_type for data_type in [SURFACE_MACHINE_CODE, CONTEXT_NODE_TAG, CATCHMENTS_MACHINE_CODE, INPUTS_NODE_TAG, STREAM_GAGE_NODE_TAG, AOI_MACHINE_CODE, SAMPLE_FRAME_MACHINE_CODE, Profile.PROFILE_MACHINE_CODE, CrossSections.CROSS_SECTIONS_MACHINE_CODE]):
                    self.add_context_menu_item(self.menu, 'Add All Layers with Features To The Map', 'add_to_map', lambda: self.add_tree_group_to_map(model_item, True))
                if model_data == EVENT_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Add New Data Capture Event', 'new', lambda: self.add_event(model_item, DATA_CAPTURE_EVENT_TYPE_ID))

                    ltpbr_menu = QtWidgets.QMenu('Low-Tech Process-Based Restoration', self)
                    self.add_context_menu_item(ltpbr_menu, 'Add New Design', 'new', lambda: self.add_event(model_item, DESIGN_EVENT_TYPE_ID))
                    self.add_context_menu_item(ltpbr_menu, 'Add New As-Built Survey', 'new', lambda: self.add_event(model_item, AS_BUILT_EVENT_TYPE_ID))
                    self.menu.addMenu(ltpbr_menu)

                elif model_data == SURFACE_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Import Existing Raster Surface Dataset', 'new', lambda: self.add_raster(model_item, False))

                elif model_data == AOI_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Import Existing AOI', 'new', lambda: self.add_aoi(model_item, AOI_MASK_TYPE_ID, DB_MODE_IMPORT))
                    self.add_context_menu_item(self.menu, 'Import from Temporary Layer', 'new', lambda: self.add_aoi(model_item, AOI_MASK_TYPE_ID, DB_MODE_IMPORT_TEMPORARY), False)
                    self.add_context_menu_item(self.menu, 'Create New (Empty) AOI', 'new', lambda: self.add_aoi(model_item, AOI_MASK_TYPE_ID, DB_MODE_CREATE))

                elif model_data == SAMPLE_FRAME_MACHINE_CODE:
                    new_sample_frame_menu = self.menu.addMenu('Create New Sample Frame ...  ')
                    self.add_context_menu_item(new_sample_frame_menu, 'Empty Sample Frame (Manual)', 'new', lambda: self.add_sample_frame(model_item, DB_MODE_NEW))   
                    self.add_context_menu_item(new_sample_frame_menu, 'From QRiS Features', 'new', lambda: self.add_sample_frame(model_item, DB_MODE_CREATE))
                    
                    import_sample_frame_menu = self.menu.addMenu('Import Sample Frame From ...  ')
                    self.add_context_menu_item(import_sample_frame_menu, 'Feature Class', 'new', lambda: self.add_sample_frame(model_item, DB_MODE_IMPORT))
                    self.add_context_menu_item(import_sample_frame_menu, 'Temporary Layer', 'new', lambda: self.add_sample_frame(model_item, DB_MODE_IMPORT_TEMPORARY), False)
                    self.add_context_menu_item(import_sample_frame_menu, 'QRiS Project', 'new', lambda: self.add_sample_frame(model_item, DB_MODE_COPY), False)

                elif model_data == CATCHMENTS_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Run USGS StreamStats (US Only)', 'new', lambda: self.add_pour_point(model_item))
                elif model_data == CONTEXT_NODE_TAG:
                    self.add_context_menu_item(self.menu, 'Browse Scratch Space', 'folder', lambda: self.browse_item(model_data, os.path.dirname(scratch_gpkg_path(self.project.project_file))))
                    self.add_context_menu_item(self.menu, 'Import Existing Context Raster', 'new', lambda: self.add_raster(model_item, True))
                    self.add_context_menu_item(self.menu, 'Import Existing Context Vector Feature Class', 'new', lambda: self.add_context_vector(model_item))
                    self.add_context_menu_item(self.menu, 'Import from Temporary Layer', 'new', lambda: self.add_context_vector(model_item, DB_MODE_IMPORT_TEMPORARY))
                elif model_data == STREAM_GAGE_MACHINE_CODE:
                    pass
                    # self.add_context_menu_item(self.menu, 'Explore Stream Gages', 'refresh', lambda: self.stream_gage_explorer())
                elif model_data == Profile.PROFILE_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Import Existing Profile', 'new', lambda: self.add_profile(model_item, DB_MODE_IMPORT))
                    self.add_context_menu_item(self.menu, 'Import from Temporary Layer', 'new', lambda: self.add_profile(model_item, DB_MODE_IMPORT_TEMPORARY))
                    self.add_context_menu_item(self.menu, 'Create New (manually digitized) Profile', 'new', lambda: self.add_profile(model_item, DB_MODE_CREATE))
                elif model_data == CrossSections.CROSS_SECTIONS_MACHINE_CODE:
                    self.add_context_menu_item(self.menu, 'Import Existing Cross Sections', 'new', lambda: self.add_cross_sections(model_item, DB_MODE_IMPORT))
                    self.add_context_menu_item(self.menu, 'Import from Temporary Layer', 'new', lambda: self.add_cross_sections(model_item, DB_MODE_IMPORT_TEMPORARY))
                    self.add_context_menu_item(self.menu, 'Create New (manually digitized) Cross Sections', 'new', lambda: self.add_cross_sections(model_item, DB_MODE_CREATE))
                else:
                    f'Unhandled group folder clicked in QRiS project tree: {model_data}'
        else:
            if self.qrave is not None and isinstance(model_data, self.qrave.ProjectTreeData):
                self.add_context_menu_item(self.menu, 'Add To Map', 'add_to_map', lambda: self.add_basemap_to_map(model_data))
            else:
                if isinstance(model_data, DBItem):
                    if isinstance(model_data, Analysis):
                        self.add_context_menu_item(self.menu, 'Open Analysis', 'analysis', lambda: self.open_analysis(model_data))
                        self.add_context_menu_item(self.menu, 'Export Analysis Table', 'table', lambda: self.export_analysis_table(model_data))
                    else:
                        if isinstance(model_data, Project) or isinstance(model_data, Event):
                            self.add_context_menu_item(self.menu, 'Add All Layers To The Map', 'add_to_map', lambda: self.add_db_item_to_map(model_item, model_data))
                            if isinstance(model_data, Event):
                                self.add_context_menu_item(self.menu, 'Add All Layers with Features To The Map', 'add_to_map', lambda: self.add_tree_group_to_map(model_item, True))
                        else:
                            self.add_context_menu_item(self.menu, 'Add To Map', 'add_to_map', lambda: self.add_db_item_to_map(model_item, model_data))
                else:
                    raise Exception('Unhandled group folder clicked in QRiS project tree: {}'.format(model_data))

                if isinstance(model_data, Project) \
                        or isinstance(model_data, Event) \
                        or isinstance(model_data, Raster) \
                        or isinstance(model_data, Mask) \
                        or isinstance(model_data, SampleFrame) \
                        or isinstance(model_data, Profile) \
                        or isinstance(model_data, CrossSections) \
                        or isinstance(model_data, PourPoint) \
                        or isinstance(model_data, ScratchVector) \
                        or isinstance(model_data, Analysis):
                    self.add_context_menu_item(self.menu, 'Properties', 'options', lambda: self.edit_item(model_item, model_data))

                if isinstance(model_data, Mask):
                    self.add_context_menu_item(self.menu, 'Zonal Statistics', 'gis', lambda: self.geospatial_summary(model_item, model_data))
                    # if model_data.mask_type.id == AOI_MASK_TYPE_ID:
                        # self.add_context_menu_item(self.menu, 'Generate Centerline', 'gis', lambda: self.generate_centerline(model_data))
                        # self.add_context_menu_item(self.menu, 'Generate Sample Frame', 'gis', lambda: self.generate_sample_frame(model_data))

                if isinstance(model_data, Raster):  # and model_data.raster_type_id != RASTER_TYPE_BASEMAP:
                    self.add_context_menu_item(self.menu, 'Raster Slider', 'slider', lambda: self.raster_slider(model_data))

                if isinstance(model_data, ScratchVector):
                    self.add_context_menu_item(self.menu, 'Generate Centerline', 'gis', lambda: self.generate_centerline(model_data))
                    if QgsVectorLayer(f'{model_data.gpkg_path}|layername={model_data.fc_name}').geometryType() == QgsWkbTypes.PolygonGeometry:
                        self.add_context_menu_item(self.menu, 'Generate Sample Frame', 'gis', lambda: self.generate_sample_frame(model_data))
                        self.add_context_menu_item(self.menu, 'Promote to AOI', 'mask', lambda: self.add_aoi(model_item, AOI_MASK_TYPE_ID, DB_MODE_PROMOTE))

                if isinstance(model_data, Profile):
                    self.add_context_menu_item(self.menu, 'Flip Profile Direction', 'gis', lambda: self.flip_line(model_data))
                    self.add_context_menu_item(self.menu, 'Generate Cross Sections', 'gis', lambda: self.generate_xsections(model_data))

                if isinstance(model_data, CrossSections):
                    self.add_context_menu_item(self.menu, 'Transect Profile', 'gis', lambda: self.generate_transect(model_data))
                    self.add_context_menu_item(self.menu, 'Generate Sample Frame', 'gis', lambda: self.generate_sample_frame(model_data))

                if isinstance(model_data, Project):
                    self.add_context_menu_item(self.menu, 'Browse Containing Folder', 'folder', lambda: self.browse_item(model_data, os.path.dirname(self.project.project_file)))
                    self.add_context_menu_item(self.menu, 'Export Project to Riverscapes Project', 'qris_icon', lambda: self.export_project(model_data))
                    # self.add_context_menu_item(self.menu, 'Set Project SRS', 'gis', lambda: self.set_project_srs(model_data))
                    self.add_context_menu_item(self.menu, 'Close Project', 'close', lambda: self.close())

                # if isinstance(model_data, Event):
                #     if model_data.event_type.id == DESIGN_EVENT_TYPE_ID:
                #         self.add_context_menu_item(self.menu, 'Export LTPBR Design...', 'qris_icon', lambda: self.export_design(model_data))

                if isinstance(model_data, EventLayer):
                    if model_data.name == 'BRAT CIS (Capacity Inference System)':
                        self.add_context_menu_item(self.menu, 'Export BRAT CIS Obeservations...', None, lambda: self.export_brat_cis(model_data))
                    if model_data.name == 'Observation Points':
                        self.add_context_menu_item(self.menu, 'Import Photos', 'camera', lambda: self.import_photos(model_item, model_data))
                    if model_data.name == 'BRAT CIS Reaches':
                        self.add_context_menu_item(self.menu, 'Import Existing SQL Brat Results...', 'new', lambda: self.import_brat_results(model_data))
                        # self.add_context_menu_item(self.menu, 'Validate Brat Capacity...', None, lambda: self.validate_brat_cis(model_data))
                    else:
                        self.add_context_menu_item(self.menu, 'Copy from Data Capture Event', 'new', lambda: self.import_dce(model_data, DB_MODE_COPY))
                        self.add_context_menu_item(self.menu, 'Import From Existing Feature Class...', 'new', lambda: self.import_dce(model_data))
                        self.add_context_menu_item(self.menu, 'Import from Temporary Layer', 'new', lambda: self.import_dce(model_data, DB_MODE_IMPORT_TEMPORARY))
                if isinstance(model_data, PourPoint):
                    self.add_context_menu_item(self.menu, 'Promote to AOI', 'mask', lambda: self.add_aoi(model_item, AOI_MASK_TYPE_ID, DB_MODE_PROMOTE), False)

                if not isinstance(model_data, Project):
                    self.add_context_menu_item(self.menu, 'Delete', 'delete', lambda: self.delete_item(model_item, model_data))

        self.menu.exec_(self.treeView.viewport().mapToGlobal(position))

    def add_context_menu_item(self, menu: QtWidgets.QMenu, menu_item_text: str, icon_file_name, slot: QtCore.pyqtSlot = None, enabled=True):
        action = menu.addAction(QtGui.QIcon(f':/plugins/qris_toolbar/{icon_file_name}'), menu_item_text)
        action.setEnabled(enabled)

        if slot is not None:
            action.triggered.connect(slot)

    def add_db_item_to_map(self, tree_node: QtGui.QStandardItem, db_item: DBItem):

        if isinstance(db_item, Mask):
            self.map_manager.build_mask_layer(db_item)
        elif isinstance(db_item, SampleFrame):
            self.map_manager.build_sample_frame_layer(db_item)
        elif isinstance(db_item, Raster):
            self.map_manager.build_raster_layer(db_item)
            # check if raster is a dem, and if there is an associated hillshade in the metadata. if so, add both to map
            if db_item.raster_type_id == 4:
                if db_item.metadata is not None and 'hillshade_raster_id' in db_item.metadata:
                    self.map_manager.build_raster_layer(self.project.rasters[db_item.metadata['hillshade_raster_id']])
        elif isinstance(db_item, Event):
            [self.map_manager.build_event_single_layer(db_item, layer) for layer in db_item.event_layers]
            [self.map_manager.build_raster_layer(raster) for raster in db_item.rasters]
        elif isinstance(db_item, Protocol):
            # determine parent node
            event_node = tree_node.parent()
            event = event_node.data(QtCore.Qt.UserRole)
            for event_layer in event.event_layers:
                if event_layer.layer in db_item.layers:
                    self.map_manager.build_event_single_layer(event, event_layer)
        elif isinstance(db_item, EventLayer):
            # determine parent node
            event_node = tree_node
            # traverse up the tree until we find the event node
            while not isinstance(event_node.data(QtCore.Qt.UserRole), Event):
                event_node = event_node.parent()
            event = event_node.data(QtCore.Qt.UserRole)
            self.map_manager.build_event_single_layer(event, db_item)
        elif isinstance(db_item, Project):
            [self.map_manager.build_mask_layer(mask) for mask in self.project.masks.values()]
            [self.map_manager.build_raster_layer(raster) for raster in self.project.surface_rasters().values()]
            [[self.map_manager.build_event_single_layer(event, event_layer) for event_layer in event.event_layers] for event in self.project.events.values()]
        elif isinstance(db_item, PourPoint):
            self.map_manager.build_pour_point_map_layer(db_item)
        elif isinstance(db_item, ScratchVector):
            self.map_manager.build_scratch_vector(db_item)
        elif isinstance(db_item, Profile):
            self.map_manager.build_profile_layer(db_item)
        elif isinstance(db_item, CrossSections):
            self.map_manager.build_cross_section_layer(db_item)

    def add_basemap_to_map(self, model_item, trigger_repaint=False):

        basemap_name = model_item.data.label
        basemap_uri = model_item.data.layer_uri
        basemap_provider = 'wms'  # model_item.data.tile_type
        raster_layer = self.basemap_manager.create_basemap_raster_layer(basemap_name, basemap_uri, basemap_provider)
        # if trigger_repaint is True:

    def add_tree_group_to_map(self, model_item: QtGui.QStandardItem, features_only=False):
        """Add all children of a group node to the map ToC
        """

        machine_code = model_item.data(QtCore.Qt.UserRole)
        if machine_code == STREAM_GAGE_MACHINE_CODE:
            self.map_manager.build_stream_gage_layer()
        else:
            for row in range(0, model_item.rowCount()):
                child_item = model_item.child(row)
                if features_only is True and isinstance(child_item.data(QtCore.Qt.UserRole), EventLayer):
                    event_layer: EventLayer = child_item.data(QtCore.Qt.UserRole)
                    fc_name = Layer.DCE_LAYER_NAMES[event_layer.layer.geom_type]
                    temp_layer = QgsVectorLayer(f'{self.project.project_file}|layername={fc_name}|subset=event_layer_id = {event_layer.layer.id} AND event_id = {event_layer.event_id}', 'temp', 'ogr')
                    if temp_layer.featureCount() == 0:
                        continue
                self.add_db_item_to_map(child_item, child_item.data(QtCore.Qt.UserRole))
                self.add_tree_group_to_map(child_item, features_only)

    def expand_tree(self):
        self.treeView.expandAll()
        return

    def collapse_tree(self):
        self.treeView.collapseAll()
        return

    def set_project_srs(self, project: Project):

        # Get the current map CRS
        canvas = self.iface.mapCanvas()
        map_crs = canvas.mapSettings().destinationCrs()
        map_crs_id = map_crs.authid()

        # Get the project srs from metadata, if it exists
        project_srs = self.project.metadata.get('project_srs', None)

        if map_crs_id == project_srs:
            QtWidgets.QMessageBox.information(self, 'Qris Project SRS', f'The current map SRS is the same as the Qris project SRS.\n\nCurrent Map SRS: {map_crs_id}\n\nCurrent Qris Project SRS: {project_srs}')
            return

        # prompt the user if they want to change the project srs to the map srs
        result = QtWidgets.QMessageBox.question(self, 'Set Qris Project SRS', f'Would you like to set the change the Qris project SRS?\n\nCurrent Map SRS: {map_crs_id}\n\nCurrent Qris Project SRS: {project_srs}\n\nOr click "Reset" to clear the Qris project SRS.',
                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Reset, QtWidgets.QMessageBox.No)
        if result == QtWidgets.QMessageBox.Yes:
            self.project.metadata['project_srs'] = map_crs_id
            self.project.update_metadata()

        if result == QtWidgets.QMessageBox.Reset:
            self.project.metadata['project_srs'] = None
            self.project.update_metadata()

    def add_event(self, parent_node, event_type_id: int):
        """Initiates adding a new data capture event"""
        if event_type_id == DESIGN_EVENT_TYPE_ID:
            self.frm_event = FrmDesign(self, self.project, event_type_id)
        elif event_type_id == AS_BUILT_EVENT_TYPE_ID:
            self.frm_event = FrmAsBuilt(self, self.project, event_type_id)
        else:
            self.frm_event = FrmEvent(self, self.project, event_type_id)

        result = self.frm_event.exec_()
        if result is not None and result != 0:
            self.add_event_to_project_tree(parent_node, self.frm_event.the_event, self.frm_event.chkAddToMap.isChecked())

    def add_analysis(self, parent_node):

        if len(self.project.sample_frames.values()) == 0:
            QtWidgets.QMessageBox.information(self, 'New Analysis Error', 'No sample frames were found in the current QRiS Project.\n\nPlease prepare a sample frame before running an analysis.')
            return
        if len(self.project.events) == 0:
            QtWidgets.QMessageBox.information(self, 'New Analysis Error', 'No data capture events were found in the current QRiS Project.\n\nPlease prepare a data capture or design event before running an analysis.')
            return

        frm = FrmAnalysisProperties(self, self.project)
        result = frm.exec_()
        if result is not None and result != 0:
            self.add_child_to_project_tree(parent_node, frm.analysis, True)
            self.open_analysis(frm.analysis)

    def open_analysis(self, analysis: Analysis):

        sample_frame: SampleFrame = analysis.sample_frame
        fc_path = f"{self.project.project_file}|layername={sample_frame.fc_name}|subset={sample_frame.fc_id_column_name} = {sample_frame.id}"
        temp_layer = QgsVectorLayer(fc_path, 'temp', 'ogr')
        if temp_layer.featureCount() < 1:
            QtWidgets.QMessageBox.warning(self, 'Empty Sample Frame', 'The sample frame for this analysis does not contain any features.\n\nPlease add features to this sample frame to proceed.')
            return

        if self.analysis_doc_widget is None:
            self.analysis_doc_widget = FrmAnalysisDocWidget(self)
            self.iface.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.analysis_doc_widget)
            self.analysis_doc_widget.visibilityChanged.connect(self.destroy_analysis_doc_widget)

        self.analysis_doc_widget.configure_analysis(self.project, analysis, None)
        self.analysis_doc_widget.show()

    def export_analysis_table(self, analysis: Analysis = None):

        frm = FrmExportMetrics(self, self.project, analysis)
        frm.exec_()

    def stream_gage_explorer(self):

        if self.stream_gage_doc_widget is None:
            self.stream_gage_doc_widget = FrmStreamGageDocWidget(self.iface, self.map_manager, self.project)
            self.iface.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.stream_gage_doc_widget)

        # self.analysis_doc_widget.configure_analysis(self.project, frm.analysis, None)
        self.stream_gage_doc_widget.show()

    def export_brat_cis(self, event_layer: EventLayer):

        # TODO find a better place for this whole mess!
        class BratCISFieldValueConverter(QgsVectorFileWriter.FieldValueConverter):

            def __init__(self, layer):
                QgsVectorFileWriter.FieldValueConverter.__init__(self)
                self.layer = layer

            def fieldDefinition(self, field):
                """Sets up field definitions for output fields. Use existing if not a special case"""
                idx = self.layer.fields().indexFromName(field.name())
                editorWidget = self.layer.editorWidgetSetup(idx)
                if editorWidget.type() == 'ValueMap':
                    return QgsField(field.displayName(), QVariant.String)
                elif field.name() == 'observation_date':
                    return QgsField(field.displayName(), QVariant.String)
                else:
                    return self.layer.fields()[idx]

            def convert(self, idx, value):
                """modify the output value here"""
                editorWidget = self.layer.editorWidgetSetup(idx)
                if editorWidget.type() == 'ValueMap':
                    valueMap = editorWidget.config()['map']
                    dictValueMapWithKeyValueSwapped = {v: k for d in valueMap for k, v in d.items()}
                    return dictValueMapWithKeyValueSwapped.get(value)
                elif isinstance(value, QDate):
                    return value.toString('yyyy-MM-dd')
                else:
                    return value

        # Select output csv file
        settings = QtCore.QSettings(ORGANIZATION, APPNAME)
        last_project_folder = settings.value(LAST_PROJECT_FOLDER)  # TODO where is the export folder?
        out_csv = QtWidgets.QFileDialog.getSaveFileName(self, "Open Existing QRiS Project", last_project_folder, self.tr("Comma Separated Values(*.csv)"))[0]

        # TODO delete file if already exists, or handle with vector file writer options...

        if out_csv != "":  # TODO better file name validation here
            cis_layer = QgsVectorLayer(f'{self.project.project_file}|layername={event_layer.layer.fc_name}')
            self.map_manager.add_brat_cis(cis_layer)  # This sets up the required aliases, and lookup values
            cis_layer.setSubsetString('event_id = ' + str(event_layer.event_id))  # filter to the capture event
            options = QgsVectorFileWriter.SaveVectorOptions()
            # Filter and order the fields. This does not affect the X, Y columns, which are prepended and cannot be renamed by the VectorFileWriter
            # fields = ['fid', 'streamside_veg_id', 'observer_name', 'reach_id', 'observation_date', 'reach_length', 'notes']
            # options.attributes = list(cis_layer.fields().indexFromName(name) for name in fields)
            options.driverName = 'CSV'
            options.layerOptions = ["STRING_QUOTING=IF_NEEDED", "GEOMETRY=AS_XY"]
            options.fieldNameSource = QgsVectorFileWriter.FieldNameSource.PreferAlias
            converter = BratCISFieldValueConverter(cis_layer)
            options.fieldValueConverter = converter
            context = QgsCoordinateTransformContext()
            result = QgsVectorFileWriter.writeAsVectorFormatV3(cis_layer, out_csv, context, options)

            # TODO error checking and message logging here

            # TODO any cleanup of lat/long header names and field order?

    def import_brat_results(self, db_item: DBItem):

        import_source_path = browse_vector(self, 'Select sql brat feature class to import.', QgsWkbTypes.GeometryType.LineGeometry)
        if import_source_path is None:
            return

        attributes = {'ReachID': 'reach_id'}
        import_existing(import_source_path, self.project.project_file, db_item.layer.fc_name, db_item.id, 'event_id', attributes, None)

        # self.add_child_to_project_tree(parent_node, db_item, True)

    def import_photos(self, parent_node, db_item: DBItem):
        # navigate to the folder containing the photos
        photos_folder = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select the folder containing the photos to import.')
        if photos_folder is None or photos_folder == '':
            return

        frm = FrmImportPhotos(self, self.project, db_item, photos_folder)
        result = frm.exec_()
        if result == QtWidgets.QDialog.Accepted:
            self.add_db_item_to_map(parent_node, db_item)

    def import_dce(self, db_item: DBItem, mode: int = DB_MODE_IMPORT):

        layer_type = Layer.GEOMETRY_TYPES[db_item.layer.geom_type]
        fc_name = Layer.DCE_LAYER_NAMES[db_item.layer.geom_type]

        if mode == DB_MODE_IMPORT:
            import_source_path = browse_vector(self, 'Select feature class to import.', layer_type)
            if import_source_path is None:
                return
            import_source_layer = QgsVectorLayer(import_source_path, 'import_source')

        if mode == DB_MODE_IMPORT_TEMPORARY:
            if mode == DB_MODE_IMPORT_TEMPORARY:
                import_source_path = self.get_temporary_layer([layer_type])
            if import_source_path is None:
                return
            import_source_layer = import_source_path

        if mode == DB_MODE_COPY:
            layer_name = db_item.layer.fc_name
            event_type = self.project.events[db_item.event_id].event_type.id
            event_name = "Data Capture Event" if event_type == DATA_CAPTURE_EVENT_TYPE_ID else "Design"
            # filter events to only those with an event layer of the same type as the layer to be copied
            dce_events = [event for event in self.project.events.values() if event.event_type.id == event_type]
            # remove the current event
            dce_events = [event for event in dce_events if event.id != db_item.event_id]
            # filter events if layer name is within the event layers
            dce_events = [event for event in dce_events if layer_name in [layer.layer.fc_name for layer in event.event_layers]]
            if len(dce_events) == 0:
                # warn user with message box and reject the dialog
                filter_message = f" with layer name '{layer_name}'" if layer_name is not None else ""
                QtWidgets.QMessageBox.warning(self, f"No {event_name}s", f"There are no {event_name}s{filter_message} in the project.")
                return

            frm = FrmEventPicker(self, self.project, DATA_CAPTURE_EVENT_TYPE_ID, events=dce_events)
            if frm.dce_events == [] or frm.dce_events is None:
                return
            result = frm.exec_()
            if result != QtWidgets.QDialog.Accepted:
                return
            import_source_path = QgsVectorLayer(f'{self.project.project_file}|layername={db_item.layer.fc_name}')
            import_source_path.setSubsetString('event_id = ' + str(frm.qris_event.id))
            import_source_layer = import_source_path

        # Get feature count of import source
        import_source_count = import_source_layer.featureCount()
        import_source_crs = import_source_layer.crs().authid()
        del import_source_layer
        if import_source_count == 0:
            QtWidgets.QMessageBox.information(self, 'Import DCE', 'No features found in the selected feature class.')
            return
        if import_source_crs is None or import_source_crs == '':
            QtWidgets.QMessageBox.information(self, 'Import DCE', 'The selected feature class does not have a valid coordinate reference system.')
            return
        if mode == DB_MODE_IMPORT_TEMPORARY:
            attributes = {'event_id': db_item.event_id, 'event_layer_id': db_item.layer.id}
            task = ImportTemporaryLayer(import_source_path, self.project.project_file, fc_name, attributes)
            task.import_complete.connect(partial(self.import_dce_complete, db_item))
            QgsApplication.taskManager().addTask(task)
            # task.run()
        elif mode == DB_MODE_COPY:
            feats = []
            source_layer = QgsVectorLayer(f'{self.project.project_file}|layername={fc_name}')
            feat_count = source_layer.featureCount() + 1
            for feature in import_source_path.getFeatures():
                new_feature = QgsFeature()
                new_feature.setFields(feature.fields())
                new_feature.setGeometry(feature.geometry())
                new_feature.setAttributes(feature.attributes())
                new_feature.setAttribute('event_id', db_item.event_id)
                new_feature.setId(feat_count)
                new_feature['fid'] = feat_count
                feats.append(new_feature)
                feat_count += 1
            source_layer.startEditing()
            source_layer.addFeatures(feats)
            source_layer.commitChanges()
            self.import_dce_complete(db_item, True)

        else:
            frm = FrmImportDceLayer(self, self.project, db_item, import_source_path)
            frm.import_complete.connect(partial(self.import_dce_complete, db_item))
            frm.exec_()

    def export_project(self, project: Project):

        # select the output directory
        basedir = os.path.dirname(self.project.project_file)
        out_dir = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Output Directory", basedir)
        if out_dir == "":
            return

        # check if there is already a project.rs.xml file in the output directory
        if os.path.exists(os.path.join(out_dir, 'project.rs.xml')):
            # warn the user that a project has already been exported to this directory
            result = QtWidgets.QMessageBox.question(self, 'Export Project', 'A project has already been exported to this directory.\n\nWould you like to overwrite the existing riverscapes project?',
                                                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if result == QtWidgets.QMessageBox.No:
                return

        frm = FrmExportProject(self, self.project, out_dir)
        result = frm.exec_()

        if result == QtWidgets.QDialog.Accepted:
            iface.messageBar().pushMessage('Export Project', 'Export Complete', level=Qgis.Success, duration=5)            

    def export_design(self, event: Event):

        # select the output directory
        basedir = os.path.dirname(self.project.project_file)
        out_dir = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Output Directory", basedir)
        if out_dir == "":
            return

        # check if there is already a project.rs.xml file in the output directory
        if os.path.exists(os.path.join(out_dir, 'project.rs.xml')):
            # warn the user that a project has already been exported to this directory
            result = QtWidgets.QMessageBox.question(self, 'Export Design', 'A design has already been exported to this directory.\n\nWould you like to overwrite the existing design?',
                                                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if result == QtWidgets.QMessageBox.No:
                return

        frm = FrmExportDesign(self, self.project, event, out_dir)
        frm.exec_()

    def import_dce_complete(self, db_item: DBItem, result: bool):

        if result is True:
            iface.messageBar().pushMessage('Import DCE', 'Import Complete', level=Qgis.Success, duration=5)
            layer = self.map_manager.get_db_item_layer(self.project.map_guid, db_item, None)
            if layer is not None:
                self.map_manager.metadata_field(layer.layer(), db_item, 'metadata')
            
            # refresh map
            iface.mapCanvas().refreshAllLayers()
            iface.mapCanvas().refresh()
        else:
            iface.messageBar().pushMessage('Import DCE', 'Import Failed', level=Qgis.Warning, duration=5)

    def validate_brat_cis(self, db_item: DBItem):

        QtWidgets.QMessageBox.information(self, "Validate BRAT", "Not implemented yet.")
        # brat_layer = db_item.event_layer

    def raster_slider(self, db_item: DBItem):

        if self.slider_doc_widget is None:
            self.slider_doc_widget = FrmSlider(self, self.project, self.map_manager)
            self.iface.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.slider_doc_widget)

        self.slider_doc_widget.export_complete.connect(self.raster_slider_export_complete)

        self.slider_doc_widget.configure_raster(db_item)
        self.slider_doc_widget.show()

    def generate_centerline(self, db_item: DBItem):

        self.add_db_item_to_map(None, db_item)

        if self.centerline_doc_widget is None:
            self.centerline_doc_widget = FrmCenterlineDocWidget(self, self.project, self.map_manager)
            self.iface.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.centerline_doc_widget)

        self.centerline_doc_widget.export_complete.connect(self.centerline_save_complete)
        self.centerline_doc_widget.centerline_setup(db_item)
        self.centerline_doc_widget.show()

    def flip_line(self, db_item: DBItem):
        flip_line_geometry(self.project, db_item)
        self.iface.mapCanvas().refreshAllLayers()

    def generate_xsections(self, db_item: DBItem):

        if self.cross_sections_doc_widget is None:
            self.cross_sections_doc_widget = FrmCrossSectionsDocWidget(self, self.project, db_item, self.map_manager)
            self.iface.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.cross_sections_doc_widget)

        self.cross_sections_doc_widget.export_complete.connect(self.save_complete)
        self.cross_sections_doc_widget.show()

    def generate_transect(self, db_item: DBItem):

        QtWidgets.QMessageBox.information(self, 'Not Implemented', 'Generating Transect Profile from Cross Sections is not yet implemented.')

    def generate_sample_frame(self, db_item: DBItem):

        cross_sections = None
        polygon = None

        if isinstance(db_item, CrossSections):
            cross_sections = db_item
        if isinstance(db_item, Mask) or isinstance(db_item, ScratchVector):
            polygon = db_item

        frm = FrmSampleFrame(self, self.project, polygon, cross_sections)
        frm.export_complete.connect(self.save_complete)
        frm.exec_()

    def add_child_to_project_tree(self, parent_node: QtGui.QStandardItem, data_item, add_to_map: bool = False, collapsed: bool=False) -> QtGui.QStandardItem:
        """
        Looks at all child nodes of the parent_node and returns the existing QStandardItem
        that has the DBitem attached. It will also update the existing node with the latest name
        in the event that the data item has just been edited.

        A new node is created if no existing node is found.

        The data_item can either be a DBItem object or a string for group nodes
        """

        # Search for a child node under the parent with the specified data attached
        target_node = None
        for row in range(0, parent_node.rowCount()):
            child_node = parent_node.child(row)
            if child_node.data(QtCore.Qt.UserRole) == data_item:
                target_node = child_node
                break

        # Create a new node if none found, or ensure the existing node has the latest name
        if target_node is None:
            icon = FOLDER_ICON
            if isinstance(data_item, DBItem):
                icon = data_item.icon
            elif data_item == STREAM_GAGE_MACHINE_CODE:
                icon = 'database'
            elif data_item == CATCHMENTS_MACHINE_CODE:
                icon = 'waterdrop-blue'

            print(data_item)
            # target node could be a string or a DBItem. if db_item, use data_item.name. if string, check if it exists in GROUP_FOLDER_LABELS, if not, use the string as is
            if isinstance(data_item, DBItem):
                target_node = QtGui.QStandardItem(data_item.name)
                if  not any(isinstance(data_item, data_class) for data_class in [Project, Event, Analysis, PourPoint, Raster, StreamGage]):
                    if isinstance(data_item, EventLayer): 
                        fc_name = Layer.DCE_LAYER_NAMES[data_item.layer.geom_type]
                        temp_layer = QgsVectorLayer(f'{self.project.project_file}|layername={fc_name}|subset=event_layer_id = {data_item.layer.id} AND event_id = {data_item.event_id}', 'temp', 'ogr')
                    else:
                        temp_layer = QgsVectorLayer(f'{self.project.project_file}|layername={data_item.fc_name}|subset={data_item.fc_id_column_name} = {data_item.id}', 'temp', 'ogr')                    
                    if temp_layer.featureCount() == 0:
                        target_node.setText(data_item.name + ' (Empty)')
                        font = target_node.font()
                        font.setItalic(True)
                        target_node.setFont(font)
            else:
                if data_item in GROUP_FOLDER_LABELS:
                    target_node = QtGui.QStandardItem(GROUP_FOLDER_LABELS[data_item])
                else:
                    target_node = QtGui.QStandardItem(data_item)
            target_node.setIcon(QtGui.QIcon(f':plugins/qris_toolbar/{icon}'))
            target_node.setData(data_item, QtCore.Qt.UserRole)
            parent_node.appendRow(target_node)
            if collapsed is True:
                self.treeView.collapse(parent_node.index())

            if add_to_map is True and isinstance(data_item, DBItem):
                self.add_db_item_to_map(target_node, data_item)

        elif isinstance(data_item, DBItem):
            target_node.setText(data_item.name)

            # Check if the item is in the map and update its name if it is
            _layer = self.map_manager.get_db_item_layer(self.project.map_guid, data_item, None)

        return target_node

    def add_event_to_project_tree(self, parent_node: QtGui.QStandardItem, event: Event, add_to_map: bool = False):
        """
        Most project data types can be added to the project tree using add_child_to_project_tree()
        but data capture events have child nodes so they need this special method.
        """

        # Event, protocols and layers
        event_node = self.add_child_to_project_tree(parent_node, event, add_to_map, collapsed=True)

        # remove event layers that no longer exist in the event
        row_adjustment = 0
        for row in range(0, event_node.rowCount()):
            row = row + row_adjustment
            child_node = event_node.child(row)
            layer = child_node.data(QtCore.Qt.UserRole)
            if isinstance(layer, str):
                continue
            if layer not in event.event_layers:
                self.map_manager.remove_db_item_layer(self.project.map_guid, layer)
                event_node.removeRow(row)
                row_adjustment -= 1

        for event_layer in event.event_layers:
            if event_layer.layer.is_lookup is False:
                node = event_node
                if event_layer.layer.hierarchy is not None:
                    for level in event_layer.layer.hierarchy:
                        node = self.add_child_to_project_tree(node, level, add_to_map, collapsed=True)
                self.add_child_to_project_tree(node, event_layer, add_to_map, collapsed=True)

    def add_raster(self, parent_node: QtGui.QStandardItem, is_context: bool, import_source_path: str = None, meta: dict = None):
        """Initiates adding a new base map to the project"""

        if import_source_path is None:
            import_source_path = browse_raster(self, 'Select a raster dataset to import.')
            if import_source_path is None:
                return

        frm = FrmRaster(self, self.iface, self.project, import_source_path, is_context)
        if meta is not None:
            frm.metadata = meta
        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.raster, frm.chkAddToMap.isChecked())
            if frm.hillshade is not None:
                self.add_child_to_project_tree(parent_node, frm.hillshade, frm.chkAddToMap.isChecked())

    def add_context_vector(self, parent_node: QtGui.QStandardItem, import_source_path: str = None, meta: dict = None):

        if import_source_path is None:
            import_source_path = browse_vector(self, 'Select a vector feature class to import.', None)
            if import_source_path is None:
                return
        if import_source_path == DB_MODE_IMPORT_TEMPORARY:
            import_source_path = self.get_temporary_layer([QgsWkbTypes.PolygonGeometry, QgsWkbTypes.LineGeometry, QgsWkbTypes.PointGeometry])
            if import_source_path is None:
                return

        frm = FrmScratchVector(self, self.iface, self.project, import_source_path, None, None)
        if meta is not None:
            frm.metadata = meta
        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.scratch_vector, frm.chkAddToMap.isChecked())

    def get_temporary_layer(self, layer_types: list) -> QgsVectorLayer:

        frm_toc = FrmTOCLayerPicker(self, "Select Temporary layer to import", layer_types)
        if not frm_toc.layer_count > 0:
            return
        result = frm_toc.exec_()
        if result != QtWidgets.QDialog.Accepted:
            return
        if frm_toc.layer is None:
            return
        return frm_toc.layer

    def add_aoi(self, parent_node: QtGui.QStandardItem, mask_type_id: int, mode: int):
        """Initiates adding a new aoi"""

        import_source_path = None
        if mode == DB_MODE_IMPORT:
            import_source_path = browse_vector(self, f'Select a polygon dataset to import as a new AOI.', QgsWkbTypes.GeometryType.PolygonGeometry)
            if import_source_path is None:
                return

        if mode == DB_MODE_IMPORT_TEMPORARY:
            import_source_path = self.get_temporary_layer([QgsWkbTypes.PolygonGeometry])
            if import_source_path is None:
                return

        if mask_type_id == AOI_MASK_TYPE_ID:
            frm = FrmMaskAOI(self, self.project, import_source_path, self.project.lookup_tables['lkp_mask_types'][mask_type_id])

        if mode == DB_MODE_PROMOTE:
            db_item = parent_node.data(QtCore.Qt.UserRole)
            frm.promote_to_aoi(db_item)

            # find the AOIs Node in the model
            rootNode = self.model.invisibleRootItem()
            project_node = self.add_child_to_project_tree(rootNode, self.project)
            inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG)
            aoi_node = self.add_child_to_project_tree(inputs_node, AOI_MACHINE_CODE)
            parent_node = aoi_node

        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.qris_mask, frm.chkAddToMap.isChecked())

    def add_sample_frame(self, parent_node: QtGui.QStandardItem, mode: int):
        """Initiates adding a new sample frame"""

        import_source_path = None
        if mode == DB_MODE_IMPORT:
            import_source_path = browse_vector(self, f'Select a polygon dataset to import as a new Sample Frame.', QgsWkbTypes.GeometryType.PolygonGeometry)
            if import_source_path is None:
                return

        if mode == DB_MODE_IMPORT_TEMPORARY:
            import_source_path = self.get_temporary_layer([QgsWkbTypes.PolygonGeometry])
            if import_source_path is None:
                return
        
        create = False
        if mode == DB_MODE_CREATE:
            create = True

        frm = FrmSampleFrame(self, self.project, import_source_path, create_sample_frame=create)

        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.sample_frame, frm.chkAddToMap.isChecked())

    def add_profile(self, parent_node: QtGui.QStandardItem, mode: int):

        import_source_path = None
        if mode == DB_MODE_IMPORT:
            import_source_path = browse_vector(self, 'Select a line dataset to import as a new profile.', QgsWkbTypes.GeometryType.LineGeometry)
            if import_source_path is None:
                return
        if mode == DB_MODE_IMPORT_TEMPORARY:
            import_source_path = self.get_temporary_layer([QgsWkbTypes.LineGeometry])
            if import_source_path is None:
                return

        frm = FrmProfile(self, self.project, import_source_path)
        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.profile, frm.chkAddToMap.isChecked())

    def add_cross_sections(self, parent_node: QtGui.QStandardItem, mode: int):

        import_source_path = None
        if mode == DB_MODE_IMPORT:
            import_source_path = browse_vector(self, 'Select a line dataset to import as a new cross section layer.', QgsWkbTypes.GeometryType.LineGeometry)
            if import_source_path is None:
                return

        if mode == DB_MODE_IMPORT_TEMPORARY:
            import_source_path = self.get_temporary_layer([QgsWkbTypes.LineGeometry])
            if import_source_path is None:
                return

        frm = FrmCrossSections(self, self.project, import_source_path)
        result = frm.exec_()
        if result != 0:
            self.add_child_to_project_tree(parent_node, frm.cross_sections, frm.chkAddToMap.isChecked())

    def add_pour_point(self, parent_node):

        QtWidgets.QMessageBox.information(self, 'Pour Point', 'Click on the map at the location of the desired pour point.'
                                          '  Be sure to click on the precise stream location.'
                                          '  A form will appear where you can provide a name and description for the point.'
                                          '  After you click OK, the pour point location will be transmitted to Stream Stats.'
                                          '  This process can take from a few seconds to a few minutes depending on the size of the catchment.')

        canvas = self.iface.mapCanvas()
        canvas.setMapTool(self.stream_stats_tool)

    def stream_stats_action(self, raw_map_point, button):

        # Revert the default tool so the user doesn't accidentally click again
        self.iface.actionPan().trigger()

        transformed_point = transform_geometry(raw_map_point, self.iface.mapCanvas().mapSettings().destinationCrs().authid(), 4326)

        try:
            state_code = get_state_from_coordinates(transformed_point.y(), transformed_point.x())
            if state_code is None:
                QtWidgets.QMessageBox.warning(self, 'Invalid Location', 'This is a service by USGS and is only available in some US States. See https://streamstats.usgs.gov/ss/ for more information.')
                return
        except Exception as ex:
            QtWidgets.QMessageBox.warning(self, 'Error Determining US State', str(ex))
            return

        frm = FrmPourPoint(self, self.project, transformed_point.y(), transformed_point.x(), None)
        result = frm.exec_()
        if result != 0:
            stream_stats = StreamStats(self.project.project_file,
                                       transformed_point.y(),
                                       transformed_point.x(),
                                       frm.txtName.text(),
                                       frm.txtDescription.toPlainText(),
                                       frm.chkBasin.isChecked(),
                                       frm.chkFlowStats.isChecked(),
                                       frm.chkAddToMap.isChecked())

            stream_stats.stream_stats_successfully_complete.connect(self.stream_stats_complete)

            # Call the run command directly during development to run the process synchronousely.
            # DO NOT DEPLOY WITH run() UNCOMMENTED
            # stream_stats.run()

            # Call the addTask() method to run the process asynchronously. Deploy with this method uncommented.
            QgsApplication.taskManager().addTask(stream_stats)

    @ pyqtSlot(PourPoint or None, bool)
    def stream_stats_complete(self, pour_point: PourPoint, add_to_map: bool):

        if isinstance(pour_point, PourPoint):
            self.iface.messageBar().pushMessage('Stream Stats Complete', f'Catchment delineation successful for {pour_point.name}.', level=Qgis.Info, duration=5)
            self.project.pour_points[pour_point.id] = pour_point

            rootNode = self.model.invisibleRootItem()
            project_node = self.add_child_to_project_tree(rootNode, self.project)
            inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG)
            context_node = self.add_child_to_project_tree(inputs_node, CONTEXT_NODE_TAG)
            catchments_node = self.add_child_to_project_tree(context_node, CATCHMENTS_MACHINE_CODE)
            self.add_child_to_project_tree(catchments_node, pour_point, add_to_map)

        else:
            self.iface.messageBar().pushMessage('Stream Stats Error', 'Check the QGIS Log for details.', level=Qgis.Warning, duration=5)

    @ pyqtSlot(ScratchVector, bool)
    def raster_slider_export_complete(self, scratch_vector: ScratchVector, add_to_map: bool):

        if isinstance(scratch_vector, ScratchVector):
            rootNode = self.model.invisibleRootItem()
            project_node = self.add_child_to_project_tree(rootNode, self.project)
            inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG)
            context_node = self.add_child_to_project_tree(inputs_node, CONTEXT_NODE_TAG)
            self.add_child_to_project_tree(context_node, scratch_vector, add_to_map)
        else:
            self.iface.messageBar().pushMessage('Export Polygon Error', 'Check the QGIS Log for details.', level=Qgis.Warning, duration=5)

    @ pyqtSlot(Profile, bool)
    def centerline_save_complete(self, centerline: Profile, add_to_map: bool):

        if isinstance(centerline, Profile):
            rootNode = self.model.invisibleRootItem()
            project_node = self.add_child_to_project_tree(rootNode, self.project)
            inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG)
            profile_node = self.add_child_to_project_tree(inputs_node, Profile.PROFILE_MACHINE_CODE)
            self.add_child_to_project_tree(profile_node, centerline, add_to_map)
        else:
            self.iface.messageBar().pushMessage('Add Centerline to Map Error', 'Check the QGIS Log for details.', level=Qgis.Warning, duration=5)

    @ pyqtSlot(DBItem, str, bool, bool)
    def save_complete(self, item: DBItem, machine_code: str, is_input_node: bool, add_to_map: bool):

        if isinstance(item, DBItem):
            rootNode = self.model.invisibleRootItem()
            project_node = self.add_child_to_project_tree(rootNode, self.project)
            inputs_node = self.add_child_to_project_tree(project_node, INPUTS_NODE_TAG) if is_input_node else project_node
            out_node = self.add_child_to_project_tree(inputs_node, machine_code)
            self.add_child_to_project_tree(out_node, item, add_to_map)
        else:
            self.iface.messageBar().pushMessage('Add to Map Error', 'Check the QGIS Log for details.', level=Qgis.Warning, duration=5)

    def edit_item(self, model_item: QtGui.QStandardItem, db_item: DBItem):

        frm = None
        if isinstance(db_item, Project):
            frm = FrmNewProject(os.path.dirname(db_item.project_file), parent=self, project=db_item)
        elif isinstance(db_item, Event):
            if db_item.event_type.id == DESIGN_EVENT_TYPE_ID:
                frm = FrmDesign(self, self.project, db_item.event_type.id, event=db_item)
            elif db_item.event_type.id == AS_BUILT_EVENT_TYPE_ID:
                frm = FrmAsBuilt(self, self.project, db_item.event_type.id, event=db_item)
            else:
                frm = FrmEvent(self, self.project, event=db_item)
        elif isinstance(db_item, Mask):
            frm = FrmMaskAOI(self, self.project, None, db_item.mask_type, db_item)
        elif isinstance(db_item, SampleFrame):
            frm = FrmSampleFrame(self, self.project, None, db_item)
        elif isinstance(db_item, Profile):
            frm = FrmProfile(self, self.project, None, db_item)
        elif isinstance(db_item, CrossSections):
            frm = FrmCrossSections(self, self.project, None, db_item)
        elif isinstance(db_item, Raster):
            frm = FrmRaster(self, self.iface, self.project, None, db_item.raster_type_id, db_item)
        elif isinstance(db_item, ScratchVector):
            frm = FrmScratchVector(self, self.iface, self.project, None, None, db_item)
        elif isinstance(db_item, PourPoint):
            frm = FrmPourPoint(self, self.project, db_item.latitude, db_item.longitude, db_item)
        elif isinstance(db_item, Analysis):
            frm = FrmAnalysisProperties(self, self.project, db_item)
        else:
            QtWidgets.QMessageBox.warning(self, 'Edit Item', 'Editing items is not yet implemented.')

        if frm is not None:
            result = frm.exec_()
            if result is not None and result != 0:

                # Adding the item into the tree again will ensure that it's name is up to date
                # and that any child nodes are correct. It will also ensure that the corresponding
                # map table of contents item is renamed.
                if isinstance(db_item, Project):
                    self.add_child_to_project_tree(self.model.invisibleRootItem(), db_item, False)
                elif isinstance(db_item, Analysis):
                    self.add_child_to_project_tree(model_item.parent(), db_item, False)
                elif isinstance(db_item, Event):
                    self.add_event_to_project_tree(model_item.parent(), db_item, frm.chkAddToMap.isChecked())
                else:
                    self.add_child_to_project_tree(model_item.parent(), db_item, frm.chkAddToMap.isChecked())

    def geospatial_summary(self, model_item, model_data: Mask):

        metrics_task = MetricsTask(self.project, model_data)
        # -- DEBUG --
        # metrics_task.run()
        # -- PRODUCTION --
        metrics_task.on_complete.connect(self.geospatial_summary_complete)
        QgsApplication.taskManager().addTask(metrics_task)
 

    def on_edit_session_change(self, mode):

        self.traverse_tree(self.model.invisibleRootItem(), self.set_edit_text)
                    
    def traverse_tree(self, node: QtGui.QStandardItem, func: callable):

        func(node)

        for row in range(0, node.rowCount()):
            child_node = node.child(row)
            escape = self.traverse_tree(child_node, func)
            if escape is True:
                break

    def set_edit_text(self, node: QtGui.QStandardItem):

        if isinstance(node.data(QtCore.Qt.UserRole), DBItem):
            layer_node: QgsLayerTreeNode = self.map_manager.get_db_item_layer(self.project.map_guid, node.data(QtCore.Qt.UserRole), None)
            if layer_node is not None:
                if isinstance(layer_node, QgsLayerTreeNode):
                    layer = layer_node.layer()
                    if layer.isEditable():
                            node.setText(node.data(QtCore.Qt.UserRole).name + ' (Editing)')
                            # make the text bold
                            font = node.font()
                            font.setBold(True)
                            font.setItalic(False)
                            node.setFont(font)
                            node.setForeground(QtGui.QBrush(QtGui.QColor(0, 0, 0)))
                            return True
                    else:
                        feature_count = layer.featureCount()
                        if feature_count == 0:
                            # set text to italic, non-bold and gray font
                            node.setText(node.data(QtCore.Qt.UserRole).name + ' (Empty)')
                            font = node.font()
                            font.setItalic(True)
                            font.setBold(False)
                            node.setFont(font)
                            node.setForeground(QtGui.QBrush(QtGui.QColor(128, 128, 128)))
                        else:
                            node.setText(node.data(QtCore.Qt.UserRole).name)
                            # make the text normal
                            font = node.font()
                            font.setBold(False)
                            font.setItalic(False)
                            node.setFont(font)
                            node.setForeground(QtGui.QBrush(QtGui.QColor(0, 0, 0)))
    
    def reconnect_layer_edits(self, node: QtGui.QStandardItem, mode=None):

        if isinstance(node.data(QtCore.Qt.UserRole), DBItem):
            layer_node: QgsLayerTreeNode = self.map_manager.get_db_item_layer(self.project.map_guid, node.data(QtCore.Qt.UserRole), None)
            if layer_node is not None:
                if isinstance(layer_node, QgsLayerTreeNode):
                    layer: QgsVectorLayer = layer_node.layer()
                    layer.editingStarted.connect(self.map_manager.start_edits)
                    layer.editingStopped.connect(self.map_manager.stop_edits)

    @ pyqtSlot(bool, Mask, dict or None, dict or None)
    def geospatial_summary_complete(self, result, model_data, polygons, data):

        if result is True:
            frm = FrmGeospatialMetrics(self, self.project, model_data, polygons, data)
            frm.exec_()
        else:
            self.iface.messageBar().pushMessage('Zonal Statistics Error', 'Check the QGIS Log for details.', level=Qgis.Warning, duration=5)

    def delete_item(self, model_item: QtGui.QStandardItem, db_item: DBItem):

        response = QtWidgets.QMessageBox.question(self, 'Confirm Delete', 'Are you sure that you want to delete the selected item?')
        if response == QtWidgets.QMessageBox.No:
            return

        # Remove the layer from the map first
        self.map_manager.remove_db_item_layer(self.project.map_guid, db_item)

        # Remove the item from the project tree
        model_item.parent().removeRow(model_item.row())

        # Remove the item from the project
        self.project.remove(db_item)

        # Delete the item from the database
        db_item.delete(self.project.project_file)

    def browse_item(self, db_item: DBItem, folder_path):

        qurl = QtCore.QUrl.fromLocalFile(folder_path)
        QtGui.QDesktopServices.openUrl(qurl)

    def setupUi(self):

        self.setWindowTitle('QRiS Plugin')

        self.resize(489, 536)
        # Top level layout must include parent. Widgets added to this layout do not need parent.
        self.dockWidgetContents = QtWidgets.QWidget(self)
        self.dockWidgetContents.setObjectName("dockWidgetContents")

        self.gridLayout = QtWidgets.QGridLayout(self.dockWidgetContents)
        self.gridLayout.setObjectName("gridLayout")
        self.treeView = QtWidgets.QTreeView(self.dockWidgetContents)
        self.treeView.setSortingEnabled(True)
        self.treeView.setHeaderHidden(True)
        self.treeView.setObjectName("treeView")
        self.treeView.header().setSortIndicatorShown(False)
        self.gridLayout.addWidget(self.treeView, 0, 0, 1, 1)
        self.setWidget(self.dockWidgetContents)
